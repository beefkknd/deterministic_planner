 ---                                                                                                           
  Code Review Report — Round 2                                                                                                                                           
                                                                                                                                                                         
  ---                                                                                                                                                                    
  CRITICAL                                                                                                                                                               
                  
  #25 — create_sub_goal() called with unknown kwargs — the #21 fix crashes at runtime

  File: f02_deterministic_planner.py:295-305

  The fix for #21 creates a failed sub-goal like this:

  sg = create_sub_goal(
      id=id_start + i,
      worker=p.worker,
      description=p.description,
      goal_type=p.goal_type,
      inputs=None,
      params=p.params if p.params else None,
      outputs=declared_outputs if declared_outputs else None,
      status="failed",      # ← NOT a parameter of create_sub_goal
      error=input_error,    # ← NOT a parameter of create_sub_goal
  )

  create_sub_goal in state.py:194-229 only accepts id, worker, description, goal_type, inputs, params, outputs. It has no status or error params. This raises TypeError
  at runtime the first time any bad InputRef is encountered. The outer except Exception in ainvoke catches it and returns status="failed" for the entire planner — so no
  sub-goals are dispatched at all, not just the bad one.

  The #21 fix is effectively disabled in practice.

  Fix options:

  Option A — Set fields after calling create_sub_goal (minimal change):
  sg = create_sub_goal(id=id_start + i, worker=p.worker, ...)
  sg = {**sg, "status": "failed", "error": input_error}

  Option B — Add status and error as optional params to create_sub_goal in state.py:
  def create_sub_goal(..., status="pending", error=None) -> SubGoal:
      return {"status": status, "error": error, ...}
  Option B is cleaner and keeps the creation logic in one place.

  ---
  #26 — Silent dead end when all dispatched sub-goals are blocked

  File: graph.py:106-108

  if not sends:
      # All pending sub-goals are blocked on unmet inputs
      return END

  This returns END while state["status"] is still "executing". F13 never runs (round counter never increments), F14 never runs, and final_response stays "". The graph
  terminates silently — the caller gets a completed run with no response.

  This happens in two concrete scenarios:
  - Scenario A: F02 creates sub-goals that depend on outputs from goals that already failed (so those outputs will never appear in completed_outputs). The pending
  sub-goals wait forever, but the graph ends before they get a chance.
  - Scenario B (after fixing #25): F02 creates a batch where every sub-goal has an invalid InputRef. All are marked status="failed" → zero pending → sends is empty → END
   with status "executing".

  Fix options:

  Option A — Add a deadlock_handler node. Route there instead of END when pending is non-empty but sends is empty:
  if not sends:
      return "deadlock_handler"  # sets status="failed", routes to f14

  Option B — Detect this condition inside F13 before looping back to F02. After join, check if there are pending sub-goals whose dependencies will never be satisfied
  (all dependencies are failed). Mark them failed, then let F02 re-plan with that context.

  Option C — Let F02 detect the stall. After fixing #25, failed sub-goals will appear in failed_context the next round IF F13 runs. So the issue is that F13 never runs
  when sends is empty. The simplest fix is: when pending is non-empty but sends is empty, route to F13 (with empty worker_results) so round increments and F02
  re-evaluates. F13 already handles the empty case (lines 49-59).

  Option C is the least invasive — change return END to return "f13_join_reduce" when pending is non-empty but sends is empty.

  ---
  HIGH

  #27 — synthesis_inputs validation drops all valid refs when one fails

  File: f02_deterministic_planner.py:428-440

  for name, ref in decision.synthesis_inputs.items():
      ...
      if from_id in completed and slot in completed[from_id]:
          validated_inputs[name] = {...}
      else:
          validated_inputs = {}   # ← discards ALL already-validated refs
          break

  If F02 specifies 4 valid synthesis refs and 1 bad one, all 4 valid refs are thrown away and F14 falls back to the deliverable-collection path. That fallback has
  different ordering and formatting than what F02 intended.

  Fix options:

  Option A — Skip bad refs instead of aborting (log a warning, keep valid ones):
  else:
      continue  # skip the bad ref, keep the valid ones

  Option B — Keep current abort behavior but log it, so at least failures are observable. The deliverable fallback is correct enough for most cases.

  ---
  #28 — existing_outputs uses declared registry outputs, not actual completed outputs

  File: f02_deterministic_planner.py:257-261

  existing_outputs = {
      sg["id"]: set(sg.get("outputs", []))
      for sg in existing_sub_goals
  }

  sg["outputs"] is the declared slot list from the registry. F05 (metadata_lookup) conditionally adds an "ambiguities" slot at runtime (line 195 of f05) which is not in
  its declared outputs: ["metadata_results", "value_results", "analysis_result"]. If F02 ever wires slot="ambiguities" from an F05 sub-goal, validation will incorrectly
  reject it — marking that sub-goal as failed even though the slot would exist at runtime.

  Fix: For slot validation against existing (already-completed) sub-goals, use completed_outputs (actual runtime outputs) instead of sg["outputs"] (declared). For
  sub-goals that are still pending, declared outputs are the only option.

  completed_outputs_map = state.get("completed_outputs", {})
  existing_outputs = {
      sg["id"]: set(
          completed_outputs_map[sg["id"]].keys()
          if sg["id"] in completed_outputs_map
          else sg.get("outputs", [])
      )
      for sg in existing_sub_goals
  }

  ---
  MEDIUM

  #29 — Dead variable resolved in F05

  File: f05_metadata_lookup.py:152

  resolved = worker_input.get("resolved_inputs", {})

  resolved is assigned but never read in ainvoke. Dead code. Either it was left from an earlier version or an intent to use it was forgotten. F05 is a "first hop" worker
   with no InputRef inputs, so this makes sense to just delete.

  ---
  #30 — F03 error dicts violate WorkerResult TypedDict contract

  File: f03_worker_executor.py:75-82, 86-93

  The inline error dicts returned in the no-worker-name and unknown-worker cases are missing the message field:

  return {
      "worker_results": [{
          "sub_goal_id": ...,
          "status": "failed",
          "outputs": {},
          "error": "No worker specified in sub_goal",
          # "message" missing
      }]
  }

  WorkerResult declares message: Optional[str]. Any consumer using result["message"] (rather than .get("message")) would get KeyError. F13 uses .get("error") and
  .get("outputs", {}) so it doesn't crash, but this is a latent defect.

  ---
  Summary Table

  #: #25
  Severity: CRITICAL
  Issue: create_sub_goal() called with invalid kwargs status/error → TypeError → entire #21 fix crashes silently
  File: f02:295-305
  Fix effort: Small — option A is one line
  ────────────────────────────────────────
  #: #26
  Severity: CRITICAL
  Issue: route_after_planner returns END with status="executing" when no sub-goals are dispatchable → silent no-response dead end
  File: graph.py:106-108
  Fix effort: Small — Option C: route to F13 instead
  ────────────────────────────────────────
  #: #27
  Severity: HIGH
  Issue: All validated synthesis refs discarded when one bad ref is found
  File: f02:428-440
  Fix effort: Small — continue instead of break+reset
  ────────────────────────────────────────
  #: #28
  Severity: HIGH
  Issue: InputRef slot validation uses declared registry outputs instead of actual completed_outputs — rejects valid runtime slots like ambiguities
  File: f02:257-261
  Fix effort: Small — use completed_outputs keys for completed sub-goals
  ────────────────────────────────────────
  #: #29
  Severity: MEDIUM
  Issue: resolved dead variable in F05
  File: f05:152
  Fix effort: Trivial — delete the line
  ────────────────────────────────────────
  #: #30
  Severity: MEDIUM
  Issue: F03 inline error dicts missing message field
  File: f03:75-93
  Fix effort: Trivial — add "message": None
